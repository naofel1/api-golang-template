/* Requires the Docker Pipeline plugin */
/*
    Angus: Out of curiosity (not a criticism), what made you choose Jenkins over GitHub Actions?


    Naofel: Thanks for your question. When I initially began creating a pipeline at work,
    Jenkins was the first tool I came across. Its comprehensiveness and user-friendly nature immediately
    struck me. While I haven't personally experimented with GitHub Actions, I really appreciate its
    simplicity and effectiveness, particularly for smaller projects such as this.

    Jenkins, however, has proven its worth by enabling me to construct a robust and efficient pipeline
    with parallel stages for quick building and deployment of applications. I believe the choice between
    the two really boils down to the specific needs and scale of the project at hand.
*/
pipeline {
    agent  {
        label 'dind-agent'
    }
    environment {
        GOCACHE = '/home/jenkins/.gocache'
        registry = 'rg.fr-par.scw.cloud/api/dev-mono-api'
        registryCredential = 'registry-credentials'
    }
    stages {
        stage('Building image') {
            steps {
                script {
                    dockerImage = docker.build(registry + ":$BUILD_NUMBER", '-f deploy/dev/Dockerfile.monolith .')
                }
            }
        }
        stage('Deploy Image') {
            steps {
                script {
                    docker.withRegistry('https://rg.fr-par.scw.cloud/api', registryCredential) {
                        dockerImage.push()
                    }
                }
            }
        }
        /*
            Angus: Wow, there's a lot going on in this repo! ArgoCD too?! Hardcore :)
            As a potential user of your API template, I would want to see more comments in your deploy files, Dockerfiles, compose file,

            Naofel:  Quite a lot happening here, including ArgoCD ðŸ˜„. When I started designing a pipeline to update my image on ArgoCD,
            it was a steep learning curve. However, the 'yq' command-line tool provided me with a straightforward method to update tags,
            which was a game-changer.

            I totally agree with you on the need for more documentation. For a potential user, the current format can be overwhelming and
            difficult to navigate. I'm going to prioritize adding comprehensive comments and improving documentation to make it more user-friendly.
            Thanks for your suggestion; it's valuable feedback like this that helps me enhance the project.
        */
        stage('Update image on ArgoCD') {
            environment {
                HELM_GIT_REPO_URL = 'gitlab.com/my-api/kubernetes.git'
                GIT_CREDS = credentials('git-credentials')
                GIT_REPO_EMAIL = 'jenkins@jenkins.com'
                GIT_REPO_BRANCH = 'dev'
            // Update above variables with your user details
            }
            steps {
                sh('git clone https://$GIT_CREDS_USR:$GIT_CREDS_PSW@$HELM_GIT_REPO_URL')
                sh('git config --global user.email $GIT_REPO_EMAIL')
                dir('kubernetes') {
                    sh('git checkout $GIT_REPO_BRANCH')
                    dir('deployment/api/dev') {
                        //install done
                        sh '''#!/bin/bash
                            ls -lth
                            yq eval '.spec.template.spec.containers[0].image = strenv(registry) + ":" + strenv(BUILD_NUMBER)' -i monolith/monolith-deployment.yaml
                            cat monolith/monolith-deployment.yaml
                            pwd
                        '''
                        sh('git add monolith/monolith-deployment.yaml')
                        sh('git commit -m "[Jenkins] Triggered Build - Update dev-mono-api image to $BUILD_NUMBER"')
                        sh('git push https://$GIT_CREDS_USR:$GIT_CREDS_PSW@$HELM_GIT_REPO_URL')
                    }
                }
            }
        }
    }
}
